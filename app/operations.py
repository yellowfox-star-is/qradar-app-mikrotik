import copy
import ipaddress
import time
import datetime


def str_with_delimiter(list0, delimiter):
    return str(delimiter).join(str(x) for x in list0)


# returns True if item is not in list, returns False if is
def is_not_in(item, list):
    return list.count(item) == 0


# REUSED CODE
# Generated by ChatGPT, verified by YellowFox
# takes a list of strings
# returns a dictionary with the strings as keys and empty lists as values
def create_dictionary(strings, init_value):
    result = {}
    for s in strings:
        result[s] = copy.deepcopy(init_value)
    return result


# REUSED CODE
# Generated by ChatGPT, verified by YellowFox
# returns "ipv4", "ipv6" or None depending on the address format
def check_ip_address(address):
    try:
        ipaddress.IPv4Address(address)
        return "ipv4"
    except ipaddress.AddressValueError:
        pass

    try:
        ipaddress.IPv6Address(address)
        return "ipv6"
    except ipaddress.AddressValueError:
        pass

    return None


def highest_power_of_two(n):
    power = 1
    while power < n:
        power <<= 1
    if power > n:
        power >>= 1
    return power


def highest_differing_bit(n1: int, n2: int):
    mask = ~0
    position = 0
    # XXX CRITICAL this is very dangerous, should be replaced with for loop
    # can fail on overflow
    while True:
        if mask & n1 == mask & n2:
            return position
        position += 1
        mask <<= 1
    return position


def fnv1a_128(data: bytes) -> bytes:
    FNV_OFFSET_BASIS = 144066263297769815596495629667062367629
    FNV_PRIME = 309485009821345068724781371

    hash = FNV_OFFSET_BASIS
    for b in data:
        hash ^= b
        hash *= FNV_PRIME
        hash %= (2**128)

    return hash.to_bytes(16, byteorder='big')


def time_ms():
    return round(time.time() * 1000)


def days_between(dt1, dt2):
    """
    Generated by Vicuna-13B, verified by Yellow Fox
    """

    # Convert timestamps to datetime objects
    dt1 = datetime.datetime.fromtimestamp(dt1)
    dt2 = datetime.datetime.fromtimestamp(dt2)

    # Calculate number of days between timestamps
    delta = abs(dt2 - dt1)
    days = delta.days + 1

    # Round up to the nearest integer
    return int(days)


def days_in_past(past_timestamp, present_timestamp=None):
    # expects timestamps in milliseconds

    if present_timestamp is None:
        present_timestamp = time_ms()

    return days_between(present_timestamp / 1000, past_timestamp / 1000)


if __name__ == "__main__":
    print(timestamp_to_days_in_past(1678895100000))
